

----------------------------------------------------------------------------------------

Question. 

You overloaded the output stream operators for Grid, Person and Point. For the first two, you needed to declare the overloaded operators as friend functions, but you did not for Point. Can you explain why was this was so?
We declared Grid to be a friend class of Point. What was the
impact of this?

----------------------------------------------------------------------------------------


Answer.

The structure Point, does not belong to the Params class, nor any other class in the program. Therefore, it was not necessary to declare this overload operator as a friend to any of the other classes. Grid was declared to be a friend class of Point, this was so the current_location could utilise the already overloaded output stream to simply print the coordinates (x,y) of the structure Point through a simple std::cout << current_location.

----------------------------------------------------------------------------------------

Question. 


We used std::shared_ptr instead of a raw pointer when passing around
the Params structure. What is the difference between a std::shared_ptr
and a std::weak_ptr ? If you change your code so that only the con- structor declaration and definition signatures change to
Person::Person (Point s, std::weak_ptr<Params> p) and you do not change any other code at all, will your code still compile? Does it run? Can you explain what is going on (i.e. the reason it either still works or is broken.).
If, instead of using pointers, we had tried to use references so that Person contained Params& params; as a member variable, then we would have gotten errors that the implicitly generated copy and move assignment operators were deleted. It wouldnâ€™t be a solution for this class, but for some, we could just write our own assignment operator. The question is why would the implicitly generated operators be deleted when a class contains a member which is a reference? (The anwer is straightforward and a general question, not related to this assignment specifically).

----------------------------------------------------------------------------------------

Answer. 

A shared_ptr wraps a reference counting mechanism around a raw pointer. So for each instance of the shared_ptr the reference count is increased by one. If two share_ptr objects refer the eachother they will never get deleted because they will never end up with a reference count of zero.

weak_ptr points to a shared_ptr but does not increase its reference count. This means that the underying object can still be deleted even though there is a weak_ptr reference to it.

The way that this works is that the weak_ptr can be use to create a shared_ptr for whenever one wants to use the underlying object. If however the object has already been deleted then an empty instance of a shared_ptr is returned. Since the reference count on the underlying object is not increased with a weak_ptr reference, a circular reference will not result in the underlying object not being deleted.

If we change the code such that the constructor declaration and definition signatures change to Person::Person (Point s, std::weak_ptr<Params> p), the code still compiles and runs. However, I can't think of a good reason as to why it still functions properly.

If, instead of using pointers, we had tried to use references so that Person contained Params& params; as a member variable, we would have gotten errors that the implicitly generated copy and move assignment operators were deleted. This is because references are bound to an object when they are initialized and can never be altered after that, everything else you do to them affects the object they are bound to, not the reference itself.

So a reference member is set during construction, and never altered. Since the purpose of an assignment operator is to alter members after construction, it doesn't make sense to generate an implicit assignment operator when one of the members can never be altered. The compiler refuses to try and guess what you want it to do and forces you to provide your own assignment operator with the semantics you want.

